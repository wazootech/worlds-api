---
title: "Deno App Management"
description: "Architectural decisions and API patterns for Deno Sandbox and Deploy management."
---

# Deno App Management

This document outlines the architectural reasoning and technical implementation details for managing Deno applications within the Worlds API console, specifically focusing on the `DenoAppManager`.

## Environment Variable Injection

Deno Deploy applications require a two-step process for proper environment variable configuration.

### The "Create and Update" Pattern

The Deno Deploy API v2 distinguishes between **Resource Identity** and **Resource Configuration**. Consequently, environment variables must be injected _after_ the initial app creation.

1.  **Identity Creation**: `POST /apps` (via `client.apps.create`) establishes the app slug and UUID.
2.  **Configuration Update**: `PATCH /apps/{id}` (via `client.apps.update`) is used to set persistent configuration like environment variables.

```typescript
// Example from DenoAppManager.ts
const app = await this.client.apps.create({ slug });

// ... perform deployment ...

await this.client.apps.update(app.id, {
  envs: envVars,
} as any);
```

> [!NOTE]
> The `@deno/sandbox` SDK (v0.12.0) may lack explicit TypeScript definitions for the `envs` field in `AppUpdate`. However, the underlying REST API supports it. Using an `as any` cast allows us to pass these variables successfully.

## Sandbox Secrets vs. App Environment Variables

It is critical to distinguish between secrets used during the build/sandbox phase and those used by the running application.

- **Sandbox Secrets**: These configure the outbound proxy for the temporary microVM used during deployment. They use "placeholders" (e.g., `{{SECRET_NAME}}`) for security.
- **App Environment Variables**: These are persistent key-value pairs used by the Deno Deploy runtime in production.

**Secrets configured in a Sandbox do NOT automatically carry over to the deployed App.** The `DenoAppManager` explicitly bridges this gap by taking `envVars` from the creation request and injecting them into the project configuration.

## Resource Lifecycle

### App Deletion

Deleting a Deno Deploy application automatically cleans up associated builds and routes. The implementation utilizes the SDK's delete method:

```typescript
await this.client.apps.delete(appId);
```

## Error Handling

Developers should be aware of where specific errors occur in the lifecycle:

- **Slug Conflicts (409)**: Occur during the **Creation** step if the requested slug is already taken.
- **Configuration Errors (400)**: Occur during the **Update** step if the environment variables or other configurations are malformed.

## Reliability and Error Handling

### Slug Collisions

When provisioning new apps, the platform implementation (`platform.ts`) automatically handles slug collisions (409 errors) by retrying with a fresh random slug (up to 3 attempts).

### Deployment Failures

The `DenoAppManager` wraps the deployment process in a `try...catch` block. If a failure occurs after the app has been created (e.g., during build or variable injection), the manager attempts to clean up the partially created app to prevent "zombie" resources.

### Timeouts

To prevent indefinite hanging, the `build.done` operation has a 2-minute timeout. If a deployment exceeds this limit, it is treated as a failure and triggers the cleanup process.
