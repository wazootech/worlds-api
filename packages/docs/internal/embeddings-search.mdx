---
title: "Embeddings & search"
description: "Implementation details for semantic search and vector embeddings."
---

## Embeddings interface

Defined in **lib/embeddings/embeddings.ts**:

A simple interface for generating vector representations of text:

- `embed(text: string): Promise<number[]>`
- `dimensions: number`

The **GeminiEmbeddings** implementation uses `@google/genai` with model `models/gemini-embedding-001`.

## Hybrid search implementation

The Search route uses **ChunksService** to run a hybrid search across one or more worlds:

1. **Resolution:** Resolves world IDs via `WorldsService`.
2. **Execution:** Gets each world client via `serverContext.libsql.manager.get(worldId)`.
3. **Hybrid Search:** Combines vector similarity (using the embeddings interface) with FTS (Full Text Search) results using **Reciprocal Rank Fusion (RRF)**.
4. **Metering:** Records usage via `UsageService`.

## Hybrid search ranking

The platform uses the **Reciprocal Rank Fusion (RRF)** algorithm to merge keyword-based and semantic-based results into a single relevance-ranked list.

The formula used in our SQL engine is:
$$score = \sum_{d \in D} \frac{1}{k + rank(d)}$$

Where:

- $k = 60$ (constant to balance top-ranked vs. bottom-ranked items).
- $rank(d)$ is the position of the document in the respective result set (Vector vs. FTS).
