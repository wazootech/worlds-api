// This file was generated by sql-embedder. Do not edit manually.

/**
 * documentsTable is a table for search documents with vector embeddings
 * and multi-tenant support.
 */
export const documentsTable =
  "CREATE TABLE IF NOT EXISTS search_documents (\n  id TEXT PRIMARY KEY,\n  tenant_id TEXT NOT NULL,\n  world_id TEXT NOT NULL,\n  subject TEXT NOT NULL,\n  predicate TEXT NOT NULL,\n  object TEXT NOT NULL,\n  embedding F32_BLOB(1536),\n  UNIQUE(tenant_id, world_id, subject, predicate, object)\n);";

/**
 * documentsAccessIndex is an index on tenant_id and world_id for efficient
 * filtering.
 */
export const documentsAccessIndex =
  "CREATE INDEX IF NOT EXISTS idx_search_documents_access ON search_documents(tenant_id, world_id);";

/**
 * documentsVectorIndex is a vector index for similarity search.
 */
export const documentsVectorIndex =
  "CREATE INDEX IF NOT EXISTS idx_search_documents_vector ON search_documents(libsql_vector_idx(embedding));";

/**
 * documentsFtsTable is an FTS5 virtual table for full-text search.
 */
export const documentsFtsTable =
  "CREATE VIRTUAL TABLE IF NOT EXISTS search_fts USING fts5(\n  object,\n  content = 'search_documents',\n  content_rowid = 'rowid'\n);";

/**
 * documentsFtsInsertTrigger is a trigger to sync FTS on insert.
 */
export const documentsFtsInsertTrigger =
  "CREATE TRIGGER IF NOT EXISTS search_documents_ai\nAFTER\nINSERT\n  ON search_documents\nBEGIN\nINSERT INTO\n  search_fts(rowid, object)\nVALUES\n  (new.rowid, new.object);\n\nEND;";

/**
 * documentsFtsDeleteTrigger is a trigger to sync FTS on delete.
 */
export const documentsFtsDeleteTrigger =
  "CREATE TRIGGER IF NOT EXISTS search_documents_ad\nAFTER\n  DELETE ON search_documents\nBEGIN\nINSERT INTO\n  search_fts(search_fts, rowid, object)\nVALUES\n  ('delete', old.rowid, old.object);\n\nEND;";

/**
 * documentsFtsUpdateTrigger is a trigger to sync FTS on update.
 */
export const documentsFtsUpdateTrigger =
  "CREATE TRIGGER IF NOT EXISTS search_documents_au\nAFTER\nUPDATE\n  ON search_documents\nBEGIN\nINSERT INTO\n  search_fts(search_fts, rowid, object)\nVALUES\n  ('delete', old.rowid, old.object);\n\nINSERT INTO\n  search_fts(rowid, object)\nVALUES\n  (new.rowid, new.object);\n\nEND;";

/**
 * documentsDeleteTenant is a query that deletes all documents for a tenant.
 */
export const documentsDeleteTenant =
  "DELETE FROM\n  search_documents\nWHERE\n  tenant_id = ?;";

/**
 * documentsDeleteWorld is a query that deletes all documents for a world
 * within a tenant.
 */
export const documentsDeleteWorld =
  "DELETE FROM\n  search_documents\nWHERE\n  tenant_id = ?\n  AND world_id = ?;";

/**
 * documentsDelete is a query that deletes a specific document by id, tenant,
 * and world.
 */
export const documentsDelete =
  "DELETE FROM\n  search_documents\nWHERE\n  id = ?\n  AND tenant_id = ?\n  AND world_id = ?;";

/**
 * documentsUpsert is a query that inserts or replaces a document with
 * embedding.
 */
export const documentsUpsert =
  "INSERT\n  OR REPLACE INTO search_documents (\n    id,\n    tenant_id,\n    world_id,\n    subject,\n    predicate,\n    object,\n    embedding\n  )\nVALUES\n  (?, ?, ?, ?, ?, ?, vector32(?));";

/**
 * documentsSearch is a query that performs hybrid search using RRF
 * (Reciprocal Rank Fusion) combining FTS and vector search.
 */
export const documentsSearch =
  "WITH vec_matches AS (\n  SELECT\n    id AS rowid,\n    row_number() OVER (PARTITION BY NULL) AS rank_number\n  FROM\n    vector_top_k('idx_search_documents_vector', vector32(?), ?)\n),\nfts_matches AS (\n  SELECT\n    rowid,\n    row_number() OVER (\n      ORDER BY\n        rank\n    ) AS rank_number,\n    rank AS score\n  FROM\n    search_fts\n  WHERE\n    search_fts MATCH ?\n  LIMIT\n    ?\n), final AS (\n  SELECT\n    search_documents.tenant_id,\n    search_documents.world_id,\n    search_documents.subject,\n    search_documents.predicate,\n    search_documents.object,\n    vec_matches.rank_number AS vec_rank,\n    fts_matches.rank_number AS fts_rank,\n    (\n      COALESCE(1.0 / (60 + fts_matches.rank_number), 0.0) * 1.0 + COALESCE(1.0 / (60 + vec_matches.rank_number), 0.0) * 1.0\n    ) AS combined_rank\n  FROM\n    fts_matches\n    FULL OUTER JOIN vec_matches ON vec_matches.rowid = fts_matches.rowid\n    JOIN search_documents ON search_documents.rowid = COALESCE(fts_matches.rowid, vec_matches.rowid)\n  WHERE\n    search_documents.tenant_id = ?\n  ORDER BY\n    combined_rank DESC\n  LIMIT\n    ?\n)\nSELECT\n  *\nFROM\n  final;";

/**
 * documentsSearchByWorlds is a query that performs hybrid search with world
 * filtering using RRF.
 */
export const documentsSearchByWorlds =
  "WITH vec_matches AS (\n  SELECT\n    id AS rowid,\n    row_number() OVER (PARTITION BY NULL) AS rank_number\n  FROM\n    vector_top_k('idx_search_documents_vector', vector32(?), ?)\n),\nfts_matches AS (\n  SELECT\n    rowid,\n    row_number() OVER (\n      ORDER BY\n        rank\n    ) AS rank_number,\n    rank AS score\n  FROM\n    search_fts\n  WHERE\n    search_fts MATCH ?\n  LIMIT\n    ?\n), final AS (\n  SELECT\n    search_documents.tenant_id,\n    search_documents.world_id,\n    search_documents.subject,\n    search_documents.predicate,\n    search_documents.object,\n    vec_matches.rank_number AS vec_rank,\n    fts_matches.rank_number AS fts_rank,\n    (\n      COALESCE(1.0 / (60 + fts_matches.rank_number), 0.0) * 1.0 + COALESCE(1.0 / (60 + vec_matches.rank_number), 0.0) * 1.0\n    ) AS combined_rank\n  FROM\n    fts_matches\n    FULL OUTER JOIN vec_matches ON vec_matches.rowid = fts_matches.rowid\n    JOIN search_documents ON search_documents.rowid = COALESCE(fts_matches.rowid, vec_matches.rowid)\n  WHERE\n    search_documents.tenant_id = ?\n    AND search_documents.world_id IN (?)\n  ORDER BY\n    combined_rank DESC\n  LIMIT\n    ?\n)\nSELECT\n  *\nFROM\n  final;";
