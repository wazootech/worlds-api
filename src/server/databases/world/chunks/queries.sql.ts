// This file was generated by sql-embedder. Do not edit manually.

/**
 * chunksTable is a table for overlapping text chunks with vector embeddings.
 */
export const chunksTable =
  "CREATE TABLE IF NOT EXISTS chunks (\n  id TEXT PRIMARY KEY,\n  triple_id TEXT NOT NULL,\n  subject TEXT NOT NULL,\n  predicate TEXT NOT NULL,\n  text TEXT NOT NULL,\n  vector F32_BLOB(1536),\n  FOREIGN KEY(triple_id) REFERENCES triples(id) ON DELETE CASCADE\n);";

/**
 * chunksTripleIdIndex is an index on triple_id for efficient retrieval.
 */
export const chunksTripleIdIndex =
  "CREATE INDEX IF NOT EXISTS idx_chunks_triple_id ON chunks(triple_id);";

/**
 * chunksSubjectIndex is an index on subject for efficient filtering.
 */
export const chunksSubjectIndex =
  "CREATE INDEX IF NOT EXISTS idx_chunks_subject ON chunks(subject);";

/**
 * chunksPredicateIndex is an index on predicate for efficient filtering.
 */
export const chunksPredicateIndex =
  "CREATE INDEX IF NOT EXISTS idx_chunks_predicate ON chunks(predicate);";

/**
 * chunksVectorIndex is a vector index for similarity search.
 */
export const chunksVectorIndex =
  "CREATE INDEX IF NOT EXISTS idx_chunks_vector ON chunks(libsql_vector_idx(vector));";

/**
 * chunksFtsTable is an FTS5 virtual table for full-text search.
 */
export const chunksFtsTable =
  "CREATE VIRTUAL TABLE IF NOT EXISTS chunks_fts USING fts5(\n  text,\n  content = 'chunks',\n  content_rowid = 'rowid'\n);";

/**
 * chunksFtsInsertTrigger is a trigger to sync FTS after insert.
 */
export const chunksFtsInsertTrigger =
  "CREATE TRIGGER IF NOT EXISTS chunks_ai\nAFTER\nINSERT\n  ON chunks\nBEGIN\nINSERT INTO\n  chunks_fts(rowid, text)\nVALUES\n  (new.rowid, new.text);\n\nEND;";

/**
 * chunksFtsDeleteTrigger is a trigger to sync FTS after delete.
 */
export const chunksFtsDeleteTrigger =
  "CREATE TRIGGER IF NOT EXISTS chunks_ad\nAFTER\n  DELETE ON chunks\nBEGIN\nINSERT INTO\n  chunks_fts(chunks_fts, rowid, text)\nVALUES\n  ('delete', old.rowid, old.text);\n\nEND;";

/**
 * chunksFtsUpdateTrigger is a trigger to sync FTS after update.
 */
export const chunksFtsUpdateTrigger =
  "CREATE TRIGGER IF NOT EXISTS chunks_au\nAFTER\nUPDATE\n  ON chunks\nBEGIN\nINSERT INTO\n  chunks_fts(chunks_fts, rowid, text)\nVALUES\n  ('delete', old.rowid, old.text);\n\nINSERT INTO\n  chunks_fts(rowid, text)\nVALUES\n  (new.rowid, new.text);\n\nEND;";

/**
 * deleteChunks is a query that deletes a specific chunk by id.
 */
export const deleteChunks = "DELETE FROM\n  chunks\nWHERE\n  id = ?;";

/**
 * upsertChunks is a query that inserts or replaces a chunk with
 * embedding.
 */
export const upsertChunks =
  "INSERT\n  OR REPLACE INTO chunks (id, triple_id, subject, predicate, text, vector)\nVALUES\n  (?, ?, ?, ?, ?, vector32(?));";

/**
 * searchChunks is a query that performs hybrid search using RRF
 * (Reciprocal Rank Fusion) combining FTS and vector search.
 */
export const searchChunks =
  "WITH vec_matches AS (\n  SELECT\n    id AS rowid,\n    row_number() OVER (PARTITION BY NULL) AS rank_number\n  FROM\n    vector_top_k('idx_chunks_vector', vector32(?), ?)\n),\nfts_matches AS (\n  SELECT\n    rowid,\n    row_number() OVER (\n      ORDER BY\n        rank\n    ) AS rank_number,\n    rank AS score\n  FROM\n    chunks_fts\n  WHERE\n    chunks_fts MATCH ?\n  LIMIT\n    ?\n), final AS (\n  SELECT\n    chunks.id,\n    chunks.triple_id,\n    chunks.subject,\n    chunks.predicate,\n    chunks.text,\n    triples.object,\n    vec_matches.rank_number AS vec_rank,\n    fts_matches.rank_number AS fts_rank,\n    (\n      COALESCE(1.0 / (60 + fts_matches.rank_number), 0.0) * 1.0 + COALESCE(1.0 / (60 + vec_matches.rank_number), 0.0) * 1.0\n    ) AS combined_rank\n  FROM\n    fts_matches\n    FULL OUTER JOIN vec_matches ON vec_matches.rowid = fts_matches.rowid\n    JOIN chunks ON chunks.rowid = COALESCE(fts_matches.rowid, vec_matches.rowid)\n    JOIN triples ON triples.id = chunks.triple_id\n  WHERE\n    (\n      ? IS NULL\n      OR chunks.subject IN (\n        SELECT\n          value\n        FROM\n          json_each(?)\n      )\n    )\n    AND (\n      ? IS NULL\n      OR chunks.predicate IN (\n        SELECT\n          value\n        FROM\n          json_each(?)\n      )\n    )\n  ORDER BY\n    combined_rank DESC\n  LIMIT\n    ?\n)\nSELECT\n  *\nFROM\n  final;";
